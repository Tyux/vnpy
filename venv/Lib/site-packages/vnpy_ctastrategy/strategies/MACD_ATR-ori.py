from vnpy_ctastrategy import (
    CtaTemplate,
    StopOrder,
    TickData,
    BarData,
    TradeData,
    OrderData,
    BarGenerator,
    ArrayManager,
)

class MacdAtrStrategy0(CtaTemplate):
    """
    基于MACD顶/底背离，结合ATR计算止盈止损，支持时间跨度的顶/底背离检测。
    """

    author = "Tong"

    # MACD参数
    fast_period = 13
    slow_period = 34
    signal_period = 9

    # ATR参数
    atr_period = 13
    risk_reward_ratio = 1.0

    # 顶/底背离检测参数
    lookback_period = 5  # 枢轴点周期
    max_pivot_points = 10  # 最大枢轴点检查数量
    max_bars = 100  # 最大K线检查范围

    macd_hist = 0.0
    atr_value = 0.0

    parameters = [
        "fast_period",
        "slow_period",
        "signal_period",
        "atr_period",
        "risk_reward_ratio",
        "lookback_period",
        "max_pivot_points",
        "max_bars",
    ]
    variables = ["macd_hist", "atr_value"]

    def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
        super().__init__(cta_engine, strategy_name, vt_symbol, setting)
        self.bg = BarGenerator(self.on_bar)
        self.am = ArrayManager()

    def detect_macd_divergence(self, macd_hist, close_prices, prd, maxpp, maxbars, mode="top"):
        """
        检测MACD顶/底背离信号
        :param macd_hist: MACD柱状图数组
        :param close_prices: 收盘价数组
        :param prd: 枢轴点周期
        :param maxpp: 最大枢轴点检查数量
        :param maxbars: 最大K线检查范围
        :param mode: "top" 检测顶背离, "bottom" 检测底背离
        :return: 是否发生背离 (True/False)
        """
        if len(macd_hist) < maxbars or len(close_prices) < maxbars:
            return False

        # 定义枢轴点
        def is_pivot(index, array, period):
            if index < period or index >= len(array) - period:
                return False
            return array[index] == max(array[index - period: index + period + 1]) if mode == "top" else array[index] == min(array[index - period: index + period + 1])

        # 找出枢轴点
        pivots = []
        for i in range(maxbars):
            if is_pivot(len(macd_hist) - i - 1, macd_hist, prd):
                pivots.append(len(macd_hist) - i - 1)
                if len(pivots) >= maxpp:
                    break

        # 检查背离条件
        for i in range(1, len(pivots)):
            macd_pivot1, macd_pivot2 = macd_hist[pivots[i - 1]], macd_hist[pivots[i]]
            price_pivot1, price_pivot2 = close_prices[pivots[i - 1]], close_prices[pivots[i]]

            if mode == "top":
                # MACD创新低，价格创新高
                if macd_pivot2 < macd_pivot1 and price_pivot2 > price_pivot1 and macd_pivot2 < 0:
                    return True
            elif mode == "bottom":
                # MACD创新高，价格创新低
                if macd_pivot2 > macd_pivot1 and price_pivot2 < price_pivot1 and macd_pivot2 > 0:
                    return True

        return False

    def on_bar(self, bar: BarData):
        """
        Callback of new bar data update.
        """
        self.cancel_all()

        am = self.am
        am.update_bar(bar)
        if not am.inited:
            return

        # 计算MACD指标
        macd, signal, hist = am.macd(self.fast_period, self.slow_period, self.signal_period, array=True)
        self.macd_hist = hist[-1]
        self.atr_value = am.atr(self.atr_period)

        # 检查顶背离和底背离
        divergence_top = self.detect_macd_divergence(
            hist, am.close, prd=self.lookback_period, maxpp=self.max_pivot_points, maxbars=self.max_bars, mode="top"
        )
        divergence_bottom = self.detect_macd_divergence(
            hist, am.close, prd=self.lookback_period, maxpp=self.max_pivot_points, maxbars=self.max_bars, mode="bottom"
        )

        # 顶背离处理
        if divergence_top:
            if self.pos > 0:
                self.sell(bar.close_price, 1)
                self.short(bar.close_price, 1)
            elif self.pos == 0:
                self.short(bar.close_price, 1)

        # 底背离处理
        if divergence_bottom:
            if self.pos < 0:
                self.cover(bar.close_price, 1)
                self.buy(bar.close_price, 1)
            elif self.pos == 0:
                self.buy(bar.close_price, 1)

        # 止盈止损逻辑
        if self.pos < 0:
            stop_loss = bar.close_price + self.atr_value
            take_profit = bar.close_price - self.atr_value * self.risk_reward_ratio
            self.buy(stop_loss, 1, stop=True)
            self.cover(take_profit, 1, stop=True)
        elif self.pos > 0:
            stop_loss = bar.close_price - self.atr_value
            take_profit = bar.close_price + self.atr_value * self.risk_reward_ratio
            self.sell(stop_loss, 1, stop=True)
            self.sell(take_profit, 1, stop=True)

        self.put_event()
