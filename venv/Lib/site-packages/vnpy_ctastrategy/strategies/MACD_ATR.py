from vnpy_ctastrategy import (
    CtaTemplate,
    StopOrder,
    TickData,
    BarData,
    TradeData,
    OrderData,
    BarGenerator,
    ArrayManager,
)
import pandas as pd

class MacdAtrStrategy(CtaTemplate):
    """
    基于MACD顶/底背离，结合ATR计算止盈止损，支持时间跨度的顶/底背离检测。
    """

    author = "Tong"

    # MACD参数
    fast_period = 13
    slow_period = 34
    signal_period = 9

    # ATR参数
    atr_period = 13
    risk_reward_ratio = 1.0

    # 顶/底背离检测参数
    lookback_period = 5  # 枢轴点周期
    max_pivot_points = 10  # 最大枢轴点检查数量
    max_bars = 100  # 最大K线检查范围
    # min_divergence_count = 1  # 最小背离数量,第几次顶底背离开始交易

    macd_hist = 0.0
    atr_value = 0.0

    parameters = [
        "fast_period",
        "slow_period",
        "signal_period",
        "atr_period",
        "risk_reward_ratio",
        "lookback_period",
        "max_pivot_points",
        "max_bars",
        # "min_divergence_count",
    ]
    variables = ["macd_hist", "atr_value"]

    def __init__(self, cta_engine, strategy_name, vt_symbol, setting):
        super().__init__(cta_engine, strategy_name, vt_symbol, setting)
        self.bg = BarGenerator(self.on_bar)
        self.am = ArrayManager()

    def detect_macd_divergence(self, macd_hist, close_prices, prd, maxpp, maxbars, mode="top"):
        if len(macd_hist) < maxbars or len(close_prices) < maxbars:
            return False

        def is_pivot(index, array, period):
            if index < period or index >= len(array) - period:
                return False
            return array[index] == max(array[index - period: index + period + 1]) if mode == "top" else array[
                                                                                                            index] == min(
                array[index - period: index + period + 1])

        pivots = []
        pivot_vals = []
        maxarraysize = 20
        for i in range(maxbars):
            if is_pivot(len(macd_hist) - i - 1, macd_hist, prd):
                pivots.insert(0, len(macd_hist) - i - 1)
                pivot_vals.insert(0, macd_hist[len(macd_hist) - i - 1])
                if len(pivots) > maxarraysize:
                    pivots.pop()
                    pivot_vals.pop()

        for i in range(len(pivots)):
            macd_pivot = pivot_vals[i]
            price_pivot = close_prices[pivots[i]]
            current_macd = macd_hist[-1]
            current_price = close_prices[-1]
            if mode == "top":
                if current_macd < macd_pivot and current_price > price_pivot and current_macd < 0:
                    start_index = len(macd_hist) - 1
                    end_index = pivots[i]
                    slope_macd = (current_macd - macd_pivot) / (end_index - start_index)
                    intercept_macd = current_macd - slope_macd * start_index
                    slope_price = (current_price - price_pivot) / (end_index - start_index)
                    intercept_price = current_price - slope_price * start_index
                    arrived = True
                    for j in range(start_index - 1, end_index, -1):
                        macd_value = slope_macd * j + intercept_macd
                        price_value = slope_price * j + intercept_price
                        if macd_hist[j] > macd_value and close_prices[j] < price_value:
                            continue
                        else:
                            arrived = False
                            break
                    if arrived:
                        return True
            elif mode == "bottom":
                if current_macd > macd_pivot and current_price < price_pivot and current_macd > 0:
                    start_index = len(macd_hist) - 1
                    end_index = pivots[i]
                    slope_macd = (current_macd - macd_pivot) / (end_index - start_index)
                    intercept_macd = current_macd - slope_macd * start_index
                    slope_price = (current_price - price_pivot) / (end_index - start_index)
                    intercept_price = current_price - slope_price * start_index
                    arrived = True
                    for j in range(start_index - 1, end_index, -1):
                        macd_value = slope_macd * j + intercept_macd
                        price_value = slope_price * j + intercept_price
                        if macd_hist[j] < macd_value and close_prices[j] > price_value:
                            continue
                        else:
                            arrived = False
                            break
                    if arrived:
                        return True
        return False

    def detect_macd_divergence1(self, macd_hist, close_prices, prd, maxpp, maxbars, mode="top"):
        """
        检测MACD顶/底背离信号
        :param macd_hist: MACD柱状图数组
        :param close_prices: 收盘价数组
        :param prd: 枢轴点周期
        :param maxpp: 最大枢轴点检查数量
        :param maxbars: 最大K线检查范围
        :param mode: "top" 检测顶背离, "bottom" 检测底背离
        :return: 是否发生背离 (True/False)
        """
        if len(macd_hist) < maxbars or len(close_prices) < maxbars:
            return False

        # 定义枢轴点
        def is_pivot(index, array, period):
            if index < period or index >= len(array) - period:
                return False
            return array[index] == max(array[index - period: index + period + 1]) if mode == "top" else array[
                                                                                                            index] == min(
                array[index - period: index + period + 1])

        # 找出枢轴点
        pivots = []
        for i in range(maxbars):
            if is_pivot(len(macd_hist) - i - 1, macd_hist, prd):
                pivots.append(len(macd_hist) - i - 1)
                if len(pivots) >= maxpp:
                    break

        # 检查背离条件
        for i in range(1, len(pivots)):
            macd_pivot1, macd_pivot2 = macd_hist[pivots[i - 1]], macd_hist[pivots[i]]
            price_pivot1, price_pivot2 = close_prices[pivots[i - 1]], close_prices[pivots[i]]

            if mode == "top":
                # MACD创新低，价格创新高初步判断
                if macd_pivot2 < macd_pivot1 and price_pivot2 > price_pivot1 and macd_pivot2 < 0:
                    # 进一步验证中间点是否符合背离趋势（添加虚拟线验证逻辑）
                    start_index = pivots[i - 1]
                    end_index = pivots[i]
                    # 计算指标（MACD柱状图）虚拟线斜率和截距
                    slope_macd = (macd_pivot1 - macd_pivot2) / (end_index - start_index)
                    intercept_macd = macd_pivot1 - slope_macd * start_index
                    # 计算价格虚拟线斜率和截距
                    slope_price = (price_pivot1 - price_pivot2) / (end_index - start_index)
                    intercept_price = price_pivot1 - slope_price * start_index
                    arrived = True
                    for j in range(start_index + 1, end_index):
                        macd_value = slope_macd * j + intercept_macd
                        price_value = slope_price * j + intercept_price
                        # 检查中间点是否符合背离趋势要求
                        if macd_hist[j] > macd_value and close_prices[j] < price_value:
                            continue
                        else:
                            arrived = False
                            break
                    if arrived:
                        return True
                else:
                    continue
            elif mode == "bottom":
                # MACD创新高，价格创新低初步判断
                if macd_pivot2 > macd_pivot1 and price_pivot2 < price_pivot1 and macd_pivot2 > 0:
                    # 进一步验证中间点是否符合背离趋势（添加虚拟线验证逻辑）
                    start_index = pivots[i - 1]
                    end_index = pivots[i]
                    # 计算指标（MACD柱状图）虚拟线斜率和截距
                    slope_macd = (macd_pivot1 - macd_pivot2) / (end_index - start_index)
                    intercept_macd = macd_pivot1 - slope_macd * start_index
                    # 计算价格虚拟线斜率和截距
                    slope_price = (price_pivot1 - price_pivot2) / (end_index - start_index)
                    intercept_price = price_pivot1 - slope_price * start_index
                    arrived = True
                    for j in range(start_index + 1, end_index):
                        macd_value = slope_macd * j + intercept_macd
                        price_value = slope_price * j + intercept_price
                        # 检查中间点是否符合背离趋势要求
                        if macd_hist[j] < macd_value and close_prices[j] > price_value:
                            continue
                        else:
                            arrived = False
                            break
                    if arrived:
                        return True
                else:
                    continue

        return False

    def detect_macd_divergence0(self, macd_hist, close_prices, prd, maxpp, maxbars, mode="top"):
        """
        检测MACD顶/底背离信号
        :param macd_hist: MACD柱状图数组
        :param close_prices: 收盘价数组
        :param prd: 枢轴点周期
        :param maxpp: 最大枢轴点检查数量
        :param maxbars: 最大K线检查范围
        :param mode: "top" 检测顶背离, "bottom" 检测底背离
        :return: 是否发生背离 (True/False)
        """
        if len(macd_hist) < maxbars or len(close_prices) < maxbars:
            return False

        # 定义枢轴点
        def is_pivot(index, array, period):
            if index < period or index >= len(array) - period:
                return False
            return array[index] == max(array[index - period: index + period + 1]) if mode == "top" else array[index] == min(array[index - period: index + period + 1])

        # 找出枢轴点
        pivots = []
        for i in range(maxbars):
            if is_pivot(len(macd_hist) - i - 1, macd_hist, prd):
                pivots.append(len(macd_hist) - i - 1)
                if len(pivots) >= maxpp:
                    break

        # 检查背离条件
        for i in range(1, len(pivots)):
            macd_pivot1, macd_pivot2 = macd_hist[pivots[i - 1]], macd_hist[pivots[i]]
            price_pivot1, price_pivot2 = close_prices[pivots[i - 1]], close_prices[pivots[i]]

            if mode == "top":
                # MACD创新低，价格创新高
                if macd_pivot2 < macd_pivot1 and price_pivot2 > price_pivot1 and macd_pivot2 < 0:
                    return True
            elif mode == "bottom":
                # MACD创新高，价格创新低
                if macd_pivot2 > macd_pivot1 and price_pivot2 < price_pivot1 and macd_pivot2 > 0:
                    return True

        return False

    def on_bar(self, bar: BarData):
        """
        Callback of new bar data update.
        """
        self.cancel_all()

        am = self.am
        am.update_bar(bar)
        if not am.inited:
            return

        # 计算MACD指标
        macd, signal, hist = am.macd(self.fast_period, self.slow_period, self.signal_period, array=True)
        self.macd_hist = hist[-1]
        self.atr_value = am.atr(self.atr_period)
        # self.atr_value = self.rma_atr(self.atr_period)

        # # 打印ATR相关信息，方便检查计算是否正确
        # print(f">>>>>>>\n当前Bar的日期/时间: {bar.datetime}")
        # print(f"最高价: {bar.high_price}")
        # print(f"最低价: {bar.low_price}")
        # print(f"收盘价: {bar.close_price}")
        #
        # print(f"计算得到的ATR值: {self.atr_value}")
        # print(f"用于计算ATR的收盘价数组（最近 {self.atr_period} 个）: {am.close[-self.atr_period:]}")

        # # 计算ATR相关步骤并打印
        # # 1. 先计算每根K线的真实波幅（TR）
        # tr_values = []
        # for i in range(1, len(am.high)):
        #     tr = max(
        #         am.high[i] - am.low[i],
        #         abs(am.high[i] - am.close[i - 1]),
        #         abs(am.low[i] - am.close[i - 1])
        #     )
        #     tr_values.append(tr)

        # print(f"当前Bar对应的真实波幅（TR）值列表（所有）: {tr_values}")
        # # 2. 根据ATR计算周期，获取用于计算当前ATR的TR值列表
        # tr_values_for_atr = tr_values[-self.atr_period:]
        # print(f"当前Bar对应的真实波幅（TR）值列表（用于计算ATR的最近 {self.atr_period} 个）: {tr_values_for_atr}")
        # # 3. 计算ATR（简单平均方式，实际可能更复杂，比如指数移动平均等，这里仅示例）
        # atr_value1 = sum(tr_values_for_atr) / len(tr_values_for_atr) if tr_values_for_atr else 0
        # print(f"手动计算得到的ATR值: {atr_value1}")







        # 检查顶背离和底背离，记录背离数量
        divergence_top = self.detect_macd_divergence(
            hist, am.close, prd=self.lookback_period, maxpp=self.max_pivot_points, maxbars=self.max_bars, mode="top"
        )
        divergence_bottom = self.detect_macd_divergence(
            hist, am.close, prd=self.lookback_period, maxpp=self.max_pivot_points, maxbars=self.max_bars, mode="bottom"
        )

        # 顶背离处理
        if divergence_top:
            if self.pos > 0:
                self.sell(bar.close_price, 1)
                self.short(bar.close_price, 1)
            elif self.pos == 0:
                self.short(bar.close_price, 1)

        # 底背离处理
        if divergence_bottom:
            if self.pos < 0:
                self.cover(bar.close_price, 1)
                self.buy(bar.close_price, 1)
            elif self.pos == 0:
                self.buy(bar.close_price, 1)

        # 止盈止损逻辑
        if self.pos < 0:
            stop_loss = bar.close_price + self.atr_value
            take_profit = bar.close_price - self.atr_value * self.risk_reward_ratio
            self.buy(stop_loss, 1, stop=True)
            self.cover(take_profit, 1, stop=True)
        elif self.pos > 0:
            stop_loss = bar.close_price - self.atr_value
            take_profit = bar.close_price + self.atr_value * self.risk_reward_ratio
            self.sell(stop_loss, 1, stop=True)
            self.sell(take_profit, 1, stop=True)

        self.put_event()

    def rma_atr(self, n):
        """
        使用RMA（相对移动平均）方式计算ATR的自定义函数
        """
        tr_values = []
        am = self.am
        for i in range(1, len(am.high)):
            tr = max(
                am.high[i] - am.low[i],
                abs(am.high[i] - am.close[i - 1]),
                abs(am.low[i] - am.close[i - 1])
            )
            tr_values.append(tr)
        tr_series = pd.Series(tr_values)
        alpha = 1 / n
        rma_tr = tr_series.ewm(alpha=alpha, adjust=False).mean()
        return rma_tr.iloc[-1]


"""
交易操作函数解释（sell、buy、short、cover）
sell函数：在这个交易策略代码中，sell函数通常用于平掉多头仓位。例如，当你持有多头仓位（已经买入了资产），调用sell函数会以指定的价格（在代码中是bar.close_price等价格）卖出资产，从而平掉多头仓位。这是一种减少多头持仓的操作，可能会导致仓位变为 0 或者空头仓位，具体取决于卖出的数量和之前的持仓情况。
buy函数：buy函数主要用于建立多头仓位。当你调用buy函数时，会以给定的价格买入资产，增加多头持仓。例如，在发现底背离并且仓位为 0（pos == 0）时，通过self.buy(bar.close_price, 1)来买入 1 个单位的资产，建立多头仓位。
short函数：short函数用于建立空头仓位。它是一种卖空操作，即预期资产价格将会下跌，先借入资产并卖出，待价格下跌后再买入归还。在发现顶背离并且仓位为 0 或者多头仓位（pos >= 0）时，通过self.short(bar.close_price, 1)来建立 1 个单位的空头仓位。
cover函数：cover函数用于平掉空头仓位。当你持有空头仓位（已经卖空了资产），调用cover函数会以指定的价格买入资产归还借入的资产，从而平掉空头仓位。例如，在发现底背离并且持有空头仓位（pos < 0）时，通过self.cover(bar.close_price, 1)来买入 1 个单位的资产平掉空头仓位。
"""