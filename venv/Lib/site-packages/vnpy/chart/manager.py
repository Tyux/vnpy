from typing import Dict, List, Tuple
from datetime import datetime
from _collections_abc import dict_keys
import numpy as np

from vnpy.trader.object import BarData

from .base import to_int


class BarManager:
    """"""

    def __init__(self) -> None:
        """"""
        self._bars: Dict[datetime, BarData] = {}
        self._datetime_index_map: Dict[datetime, int] = {}
        self._index_datetime_map: Dict[int, datetime] = {}

        self._price_ranges: Dict[Tuple[int, int], Tuple[float, float]] = {}
        self._volume_ranges: Dict[Tuple[int, int], Tuple[float, float]] = {}

    def update_history(self, history: List[BarData]) -> None:
        """
        Update a list of bar data.
        """
        # Put all new bars into dict
        for bar in history:
            self._bars[bar.datetime] = bar

        # Sort bars dict according to bar.datetime
        self._bars = dict(sorted(self._bars.items(), key=lambda tp: tp[0]))

        # Update map relationiship
        ix_list: range = range(len(self._bars))
        dt_list: dict_keys = self._bars.keys()

        self._datetime_index_map = dict(zip(dt_list, ix_list))
        self._index_datetime_map = dict(zip(ix_list, dt_list))

        # Clear data range cache
        self._clear_cache()

    def update_bar(self, bar: BarData) -> None:
        """
        Update one single bar data.
        """
        dt: datetime = bar.datetime

        if dt not in self._datetime_index_map:
            ix: int = len(self._bars)
            self._datetime_index_map[dt] = ix
            self._index_datetime_map[ix] = dt

        self._bars[dt] = bar

        self._clear_cache()

    def get_count(self) -> int:
        """
        Get total number of bars.
        """
        return len(self._bars)

    def get_index(self, dt: datetime) -> int:
        """
        Get index with datetime.
        """
        return self._datetime_index_map.get(dt, None)

    def get_datetime(self, ix: float) -> datetime:
        """
        Get datetime with index.
        """
        ix: int = to_int(ix)
        return self._index_datetime_map.get(ix, None)

    def get_bar(self, ix: float) -> BarData:
        """
        Get bar data with index.
        """
        ix: int = to_int(ix)
        dt: datetime = self._index_datetime_map.get(ix, None)
        if not dt:
            return None

        return self._bars[dt]

    def get_all_bars(self) -> List[BarData]:
        """
        Get all bar data.
        """
        return list(self._bars.values())

    def get_price_range(self, min_ix: float = None, max_ix: float = None) -> Tuple[float, float]:
        """
        Get price range to show within given index range.
        """
        if not self._bars:
            return 0, 1

        if not min_ix:
            min_ix: int = 0
            max_ix: int = len(self._bars) - 1
        else:
            min_ix: int = to_int(min_ix)
            max_ix: int = to_int(max_ix)
            max_ix = min(max_ix, self.get_count())

        buf: tuple = self._price_ranges.get((min_ix, max_ix), None)
        if buf:
            return buf

        bar_list: List[BarData] = list(self._bars.values())[min_ix:max_ix + 1]
        first_bar: BarData = bar_list[0]
        max_price: float = first_bar.high_price
        min_price: float = first_bar.low_price

        for bar in bar_list[1:]:
            max_price = max(max_price, bar.high_price)
            min_price = min(min_price, bar.low_price)

        self._price_ranges[(min_ix, max_ix)] = (min_price, max_price)
        return min_price, max_price

    def get_volume_range(self, min_ix: float = None, max_ix: float = None) -> Tuple[float, float]:
        """
        Get volume range to show within given index range.
        """
        if not self._bars:
            return 0, 1

        if not min_ix:
            min_ix: int = 0
            max_ix: int = len(self._bars) - 1
        else:
            min_ix: int = to_int(min_ix)
            max_ix: int = to_int(max_ix)
            max_ix = min(max_ix, self.get_count())

        buf: tuple = self._volume_ranges.get((min_ix, max_ix), None)
        if buf:
            return buf

        bar_list: List[BarData] = list(self._bars.values())[min_ix:max_ix + 1]

        first_bar: BarData = bar_list[0]
        max_volume = first_bar.volume
        min_volume = 0

        for bar in bar_list[1:]:
            max_volume = max(max_volume, bar.volume)

        self._volume_ranges[(min_ix, max_ix)] = (min_volume, max_volume)
        return min_volume, max_volume

    def _clear_cache(self) -> None:
        """
        Clear cached range data.
        """
        self._price_ranges.clear()
        self._volume_ranges.clear()

    def clear_all(self) -> None:
        """
        Clear all data in manager.
        """
        self._bars.clear()
        self._datetime_index_map.clear()
        self._index_datetime_map.clear()

        self._clear_cache()

    def _calculate_ema0(self, data: List[float], period: int) -> List[float]:
        """
        计算指数移动平均线（EMA），采用递归方式计算，初始值采用简单平均来近似。
        """
        if len(data) < period:
            return []
        emas = [sum(data[:period]) / period]
        alpha = 2 / (period + 1)
        for i in range(period, len(data)):
            ema = alpha * data[i] + (1 - alpha) * emas[-1]
            emas.append(ema)
        return emas

    def _calculate_ema(self, data: List[float], period: int) -> List[float]:
        data_np = np.array(data)
        alpha = 2 / (period + 1)
        emas = np.zeros_like(data_np)
        emas[period - 1] = np.mean(data_np[:period])
        for i in range(period, len(data_np)):
            emas[i] = alpha * data_np[i] + (1 - alpha) * emas[i - 1]
        return emas.tolist()

    def get_macd_data(self, ix: float) -> Tuple[float, float]:
        ix: int = to_int(ix)
        bar_list: List[BarData] = self.get_all_bars()
        if ix >= len(bar_list):
            return 0, 0

        close_prices = [bar.close_price for bar in bar_list]
        if len(close_prices) < 26:  # 因为计算MACD涉及至少26个周期的数据，这里简单判断数据量是否足够，可根据实际调整
            return 0, 0

        # 计算短期EMA（例如12周期，这里周期可配置，暂用12示例）
        ema12 = self._calculate_ema(close_prices, 12)
        if len(ema12) <= ix:  # 检查生成的ema12长度是否够用于索引访问
            return 0, 0
        # 计算长期EMA（例如26周期，这里周期可配置，暂用26示例）
        ema26 = self._calculate_ema(close_prices, 26)
        if len(ema26) <= ix:  # 检查生成的ema26长度是否够用于索引访问
            return 0, 0

        macd_line = [e12 - e26 for e12, e26 in zip(ema12, ema26)]
        if len(macd_line) <= ix:  # 检查生成的macd_line长度是否够用于索引访问
            return 0, 0

        # 计算信号线（例如9周期的EMA，这里周期可配置，暂用9示例）
        signal_line = self._calculate_ema(macd_line, 9)
        if len(signal_line) <= ix:  # 检查生成的signal_line长度是否够用于索引访问
            return 0, 0

        return macd_line[ix], signal_line[ix]

    def get_macd_range(self, min_ix: float = None, max_ix: float = None) -> Tuple[float, float]:
        """
        获取给定索引范围对应的MACD值的范围。
        """
        if not self._bars:
            return 0, 0

        if not min_ix:
            min_ix: int = 0
            max_ix: int = len(self._bars) - 1
        else:
            min_ix: int = to_int(min_ix)
            max_ix: int = to_int(max_ix)
            max_ix = min(max_ix, self.get_count())

        macd_values = []
        bar_list: List[BarData] = self.get_all_bars()
        for ix in range(min_ix, max_ix + 1):
            macd_value, _ = self.get_macd_data(ix)  # 这里忽略信号线的值，只获取MACD线的值
            macd_values.append(macd_value)

        return min(macd_values), max(macd_values)
